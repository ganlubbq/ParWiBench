--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         3145728 B, 64 B, 12-way associative
Command:          ./CEEq.out 5 2 2 2
Data file:        cg1.out
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   /home/troore/Projects/comm/ParWiBench/lte/src/Equalizing/Equalizer.cpp
Auto-annotation:  off

--------------------------------------------------------------------------------
         Ir  I1mr  ILmr          Dr   D1mr   DLmr         Dw    D1mw    DLmw 
--------------------------------------------------------------------------------
556,344,618 2,689 2,395 139,799,059 30,728 11,332 85,286,382 182,772 173,375  PROGRAM TOTALS

--------------------------------------------------------------------------------
         Ir I1mr ILmr         Dr  D1mr  DLmr         Dw    D1mw    DLmw  file:function
--------------------------------------------------------------------------------
185,301,884   17   17 31,367,196     1     1 10,903,160      14      13  /home/troore/Projects/comm/ParWiBench/util/gauss.cpp:ran1(int*)
 55,597,388  101   94 12,429,474    56    10  9,349,608   1,464     115  /home/aurel32/eglibc-stable/eglibc-2.13/stdio-common/printf_fp.c:__printf_fp
 32,447,996   56   28  8,985,600    16     4  8,112,004      15       5  /home/aurel32/eglibc-stable/eglibc-2.13/stdio-common/vfprintf.c:vfprintf
 24,090,768    2    2 11,118,816     0     0 11,118,816 164,145 164,103  /usr/include/c++/4.7/complex:std::complex<float>::complex(float, float)
 19,944,180    2    2  9,972,090     0     0  7,977,672       2       2  /home/aurel32/eglibc-stable/eglibc-2.13/gmon/../sysdeps/x86_64/_mcount.S:mcount
 14,779,205    4    4  4,552,330     0     0  2,276,165       1       1  /home/aurel32/eglibc-stable/eglibc-2.13/stdio-common/printf_fp.c:hack_digit.15956
 12,699,515   14   14         20     0     0  1,269,940       0       0  /home/troore/Projects/comm/ParWiBench/lte/include/lte_phy.h:LTE_PHY_PARAMS::LTE_PHY_PARAMS()
 12,321,600   44   44  4,155,600 5,129 3,601  1,052,400   6,023   3,601  /home/troore/Projects/comm/ParWiBench/lte/src/Equalizing/Equalizer.cpp:FDLSEqualization(std::complex<float>*, std::complex<float>**, int, int, int, int, std::complex<float>*)
 11,724,391   20   12  3,208,907 3,616     0  1,728,072       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/malloc/malloc.c:_int_free
 11,520,000    3    3  5,990,400     0     0  4,608,000       0       0  /usr/include/c++/4.7/complex:std::complex<float>& std::complex<float>::operator*=<float>(std::complex<float> const&)
 11,398,800   11   11    465,600     0     0    460,800       0       0  ???:__mulsc3
 11,241,768    6    6  1,648,106     0     0  1,114,637       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/stdlib/../sysdeps/x86_64/mul_1.S:__mpn_mul_1
 11,013,011   49   38  3,370,518    22     1  2,210,792   3,630   3,614  /home/aurel32/eglibc-stable/eglibc-2.13/malloc/malloc.c:_int_malloc
 10,969,299    4    2  3,988,836     6     1    997,209       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/gmon/mcount.c:__mcount_internal
 10,857,627   12    7  2,246,550     2     1  1,747,230     207      19  /home/aurel32/eglibc-stable/eglibc-2.13/libio/fileops.c:_IO_file_xsputn@@GLIBC_2.2.5
 10,838,400   10   10  3,283,200     0     0  1,353,600       0       0  /home/troore/Projects/comm/ParWiBench/util/matrix.cpp:void MatrixProd<int, std::complex<float> >(int, int, int, std::complex<float>**, std::complex<float>**, std::complex<float>**)
 10,152,341   11    6  3,024,105    17     2  1,080,039       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/malloc/malloc.c:malloc
  9,504,000    4    4  2,956,800     0     0  2,217,600       0       0  /home/troore/Projects/comm/ParWiBench/util/matrix.cpp:std::complex<float> InnerProd<int, std::complex<float> >(int, std::complex<float>*, std::complex<float>*)
  8,510,599    6    4  2,942,460 3,002     0    681,615       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/malloc/malloc.c:free
  5,740,800    4    2    499,200     0     0          0       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/string/../sysdeps/x86_64/strchrnul.S:strchrnul
  5,529,600    2    2  2,304,000     0     0  2,073,600       0       0  /usr/include/c++/4.7/complex:std::complex<float> std::operator*<float>(std::complex<float> const&, std::complex<float> const&)
  5,491,200    2    2  2,745,600     0     0  1,478,400       0       0  /usr/include/c++/4.7/complex:std::complex<float>& std::complex<float>::operator+=<float>(std::complex<float> const&)
  5,403,812   88   88  1,132,224 1,452   219    365,740       1       1  /home/aurel32/eglibc-stable/eglibc-2.13/math/../sysdeps/ieee754/dbl-64/e_log.c:__ieee754_log
  4,744,800   30   30  1,665,600     1     1    506,400       0       0  /home/troore/Projects/comm/ParWiBench/util/matrix.cpp:void MatrixInv<int, std::complex<float> >(int, std::complex<float>**, std::complex<float>**)
  4,406,400    1    0  1,468,800     0     0  1,468,800       0       0  /usr/include/c++/4.7/complex:std::complex<float>::imag() const
  3,916,800    0    0  1,468,800     0     0  1,468,800       0       0  /usr/include/c++/4.7/complex:std::complex<float>::real() const
  3,459,690   48   48    300,563     3     3     63,950       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/math/../sysdeps/ieee754/dbl-64/dosincos.c:__dubsin
  3,240,045    4    2    648,009     0     0    648,009       0       0  ???:operator new(unsigned long)
  3,024,064   10   10    873,614     2     0    672,021   4,202       0  /home/troore/Projects/comm/ParWiBench/util/GeneralFunc.cpp:GeneRandomInput(std::complex<float>*, int, char const*, char const*)
  3,011,330    5    5  1,238,132     1     1    889,542       0       0  /home/troore/Projects/comm/ParWiBench/util/gauss.cpp:gauss1(int*)
  3,003,292  195  170  3,002,591   170    42        383      13      11  ???:???
  2,745,600    6    3    124,800     0     0  1,248,000       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/stdio-common/fprintf.c:fprintf
  2,275,200    2    2    892,800     0     0    547,200       0       0  /home/troore/Projects/comm/ParWiBench/util/matrix.cpp:void MatrixProd<int, std::complex<float> >(int, int, int, std::complex<float>**, std::complex<float>*, std::complex<float>*)
  1,545,600    3    3    134,400     0     0    336,000       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/stdlib/../sysdeps/ieee754/dbl-64/dbl2mpn.c:__mpn_extract_double
  1,401,640   28   27    391,209 1,208   599    135,612       5       3  /home/troore/Projects/comm/ParWiBench/lte/src/Equalizing/Equalizer.cpp:LSFreqDomain(std::complex<float>*, std::complex<float>*, int, int, int)
  1,344,014    3    2    192,002     0     0          0       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/math/../sysdeps/ieee754/dbl-64/wordsize-64/s_isnan.c:isnan
  1,277,747    7    7    134,521     5     5          0       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/string/../sysdeps/x86_64/multiarch/../strlen.S:__GI_strlen
  1,209,600    3    3    134,400     0     0     67,200       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/string/../sysdeps/x86_64/memcpy.S:__GI_mempcpy
  1,036,834    5    5    316,808 3,598     0    115,214       0       0  /home/troore/Projects/comm/ParWiBench/util/GeneralFunc.cpp:WriteOutputToFiles(std::complex<float>*, int, char const*, char const*)
  1,008,000    2    2    134,400     0     0     67,200       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/stdlib/../sysdeps/x86_64/lshift.S:__mpn_lshift
  1,003,623   92   92    194,788    50    50     71,442       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/math/../sysdeps/ieee754/dbl-64/s_sin.c:sin
    998,400    2    1          0     0     0    374,400       2       1  /home/aurel32/eglibc-stable/eglibc-2.13/stdio-common/printf-parse.h:vfprintf
    960,000    2    2    499,200     0     0    384,000       0       0  /usr/include/c++/4.7/complex:std::complex<float>& std::complex<float>::operator/=<float>(std::complex<float> const&)
    873,600    1    1     67,200     0     0          0       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/math/../sysdeps/ieee754/dbl-64/wordsize-64/s_isinf.c:isinf
    864,012    2    1    216,003     0     0    216,003       0       0  ???:operator new[](unsigned long)
    801,600    9    9     67,200     3     3     38,400       0       0  ???:__divsc3
    788,103    3    3    139,077     0     0     92,718       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/stdlib/../sysdeps/x86_64/rshift.S:__mpn_rshift
    739,200    2    2    201,600     2     2    134,400       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/math/w_log.c:log
    723,774   53   53    142,089     9     8     49,414       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/math/../sysdeps/ieee754/dbl-64/s_sin.c:cos
    705,600    2    2    235,200     0     0    134,400       0       0  /home/aurel32/eglibc-stable/eglibc-2.13/math/w_sqrt.c:sqrt
    648,009    1    1          0     0     0          0       0       0  ???:operator delete(void*)
    607,200   15   14    142,800     0     0     69,600       0       0  /home/troore/Projects/comm/ParWiBench/lte/src/Equalizing/Equalizer.cpp:FDLSEstimation(std::complex<float>**, std::complex<float>**, std::complex<float>**, std::complex<float>**, int, int)
    578,347   19   17     91,066 1,369 1,114     30,430      27      13  /home/aurel32/eglibc-stable/eglibc-2.13/elf/dl-lookup.c:_dl_lookup_symbol_x

--------------------------------------------------------------------------------
-- User-annotated source: /home/troore/Projects/comm/ParWiBench/lte/src/Equalizing/Equalizer.cpp
--------------------------------------------------------------------------------
       Ir I1mr ILmr      Dr  D1mr  DLmr      Dw  D1mw  DLmw 

        .    .    .       .     .     .       .     .     .  
        .    .    .       .     .     .       .     .     .  #include "Equalizer.h"
        .    .    .       .     .     .       .     .     .  
        .    .    .       .     .     .       .     .     .  //std::complex<float> ***VpCSI;
        .    .    .       .     .     .       .     .     .  std::complex<float> ***pEqW;
        .    .    .       .     .     .       .     .     .  std::complex<float> ***pHdm;
        .    .    .       .     .     .       .     .     .  
        .    .    .       .     .     .       .     .     .  void Equalizer_init(LTE_PHY_PARAMS *lte_phy_params)
        8    1    1       0     0     0       6     0     0  {
        3    0    0       2     0     0       1     0     0  	int MDFTPerUser = lte_phy_params->N_dft_sz;
        3    0    0       2     0     0       1     0     0  	int NumLayerPerUser = lte_phy_params->N_tx_ant;
        3    1    1       2     0     0       1     0     0  	int NumRxAntenna = lte_phy_params->N_rx_ant;
        .    .    .       .     .     .       .     .     .  	
        6    0    0       1     0     0       2     1     0  	pEqW = new std::complex<float>**[MDFTPerUser];
        .    .    .       .     .     .       .     .     .  	
    7,207    1    1   3,602     0     0       1     1     1  	for(int m=0;m<MDFTPerUser;m++)
        .    .    .       .     .     .       .     .     .  	{
   13,200    1    1   3,600     0     0   2,400   150   149  		*(pEqW+m) = new std::complex<float>*[NumLayerPerUser];
   22,800    0    0   9,600     0     0   1,200     0     0  		for(int l=0;l<NumLayerPerUser;l++)
        .    .    .       .     .     .       .     .     .  		{
  110,400    1    1  12,000     0     0   9,600     0     0  			*(*(pEqW+m)+l) = new std::complex<float>[NumRxAntenna];
        .    .    .       .     .     .       .     .     .  		}
        .    .    .       .     .     .       .     .     .  	}
        .    .    .       .     .     .       .     .     .  
        6    1    1       1     0     0       2     0     0  	pHdm = new std::complex<float> **[MDFTPerUser];
    7,207    1    1   3,602     0     0       1     0     0  	for(int m=0;m<MDFTPerUser;m++)
        .    .    .       .     .     .       .     .     .  	{
   13,200    1    1   3,600     0     0   2,400   150   149  		*(pHdm+m) = new std::complex<float> *[NumRxAntenna];
   22,800    0    0   9,600     0     0   1,200     0     0  		for(int nrx=0;nrx<NumRxAntenna;nrx++)
        .    .    .       .     .     .       .     .     .  		{
  110,400    1    1  12,000     0     0   9,600     0     0  			*(*(pHdm+m)+nrx) = new std::complex<float>[NumLayerPerUser];
        .    .    .       .     .     .       .     .     .  		}
        .    .    .       .     .     .       .     .     .  	}
        6    0    0       5     1     0       0     0     0  }
        .    .    .       .     .     .       .     .     .  
        .    .    .       .     .     .       .     .     .  void FDLSEstimation(std::complex<float>** pXt, std::complex<float>** pXtDagger, std::complex<float>** pYt, std::complex<float>** pHTranspose, int NumLayer, int NumRxAntenna)
   15,600    2    1       0     0     0  13,200     0     0  {
        .    .    .       .     .     .       .     .     .  //////////////////// Freq Domain Estimate HTranspose ////////////////////
    7,200    0    0   1,200     0     0   2,400     0     0  	std::complex<float>** pXDX=new std::complex<float>*[NumLayer];
  121,200    2    2  16,800     0     0  10,800     0     0  	for(int layer=0;layer<NumLayer;layer++){*(pXDX+layer)=new std::complex<float>[NumLayer];}
   12,000    1    1   6,000     0     0   1,200     0     0  	MatrixProd<int,std::complex<float> >(NumLayer,2,NumLayer,pXtDagger,pXt,pXDX);
        .    .    .       .     .     .       .     .     .  
    7,200    0    0   1,200     0     0   2,400     0     0  	std::complex<float>** pInvXDX=new std::complex<float>*[NumLayer];
  121,200    2    2  16,800     0     0  10,800     0     0  	for(int layer=0;layer<NumLayer;layer++){*(pInvXDX+layer)=new std::complex<float>[NumLayer];}
    7,200    0    0   3,600     0     0   1,200     0     0  	MatrixInv<int,std::complex<float> >(NumLayer,pXDX,pInvXDX);
        .    .    .       .     .     .       .     .     .  
    7,200    1    1   1,200     0     0   2,400     0     0  	std::complex<float>** pXDY=new std::complex<float>*[NumLayer];
  121,200    2    2  16,800     0     0  10,800     0     0  	for(int layer=0;layer<NumLayer;layer++){*(pXDY+layer)=new std::complex<float>[NumRxAntenna];}
   12,000    0    0   6,000     0     0   1,200     0     0  	MatrixProd<int,std::complex<float> >(NumLayer,2,NumRxAntenna,pXtDagger,pYt,pXDY);
        .    .    .       .     .     .       .     .     .  
   12,000    1    1   7,200     0     0   1,200     0     0  	MatrixProd<int,std::complex<float> >(NumLayer,NumLayer,NumRxAntenna,pInvXDX,pXDY,pHTranspose);
        .    .    .       .     .     .       .     .     .  
  138,000    3    3  52,800     0     0   8,400     0     0  	for(int layer=0;layer<NumLayer;layer++){delete[] *(pXDX+layer);delete[] *(pInvXDX+layer);delete[] *(pXDY+layer);}
   18,000    1    1   7,200     0     0   3,600     0     0  	delete[] pXDX; delete[] pInvXDX; delete[] pXDY;  
        .    .    .       .     .     .       .     .     .  //////////////////// END Freq Domain Estimate HTranspose ////////////////////
    7,200    0    0   6,000     0     0       0     0     0  }
        .    .    .       .     .     .       .     .     .  
        .    .    .       .     .     .       .     .     .  
        .    .    .       .     .     .       .     .     .  void FDLSEqualization(std::complex<float> *pInpData, std::complex<float>** pHTranspose, int m, int NumLayer, int NumRxAntenna, int MDFTPerUser, std::complex<float> *pOutData)
   15,600    1    1       0     0     0  13,200     0     0  {
    1,200    0    0       0     0     0   1,200     0     0  	int NumULSymbSF = LTE_PHY_N_SYMB_PER_SUBFR;
        .    .    .       .     .     .       .     .     .  //////////////////// Freq Domain Equalize received Data /////////////////
    7,200    0    0   1,200     0     0   2,400     0     0  	std::complex<float>** pH=new std::complex<float>*[NumRxAntenna];
  121,200    2    2  16,800     0     0  10,800     0     0  	for(int nrx=0;nrx<NumRxAntenna;nrx++){*(pH+nrx)=new std::complex<float>[NumLayer];}
    7,200    1    1   1,200     0     0   2,400     0     0  	std::complex<float>** pHDagger=new std::complex<float>*[NumLayer];
  121,200    2    2  16,800     0     0  10,800     0     0  	for(int layer=0;layer<NumLayer;layer++){*(pHDagger+layer)=new std::complex<float>[NumRxAntenna];}
    7,200    0    0   1,200     0     0   2,400     0     0  	std::complex<float>** pHDH=new std::complex<float>*[NumLayer];
  121,200    2    2  16,800     0     0  10,800     0     0  	for(int layer=0;layer<NumLayer;layer++){*(pHDH+layer)=new std::complex<float>[NumLayer];}
    7,200    1    1   1,200     0     0   2,400     0     0  	std::complex<float>** pInvHDH=new std::complex<float>*[NumLayer];
  121,200    2    2  16,800     0     0  10,800     0     0  	for(int layer=0;layer<NumLayer;layer++){*(pInvHDH+layer)=new std::complex<float>[NumLayer];}
        .    .    .       .     .     .       .     .     .  
   43,200    1    1   1,200     0     0   4,800     0     0  	std::complex<float>* pHDY=new std::complex<float>[NumLayer];
        .    .    .       .     .     .       .     .     .  
   22,800    1    1   9,600     0     0   1,200     0     0  	for(int nrx=0;nrx<NumRxAntenna;nrx++)
        .    .    .       .     .     .       .     .     .  	{
   45,600    0    0  19,200     0     0   2,400     0     0  		for(int layer=0;layer<NumLayer;layer++)
        .    .    .       .     .     .       .     .     .  		{
  115,200    2    2  48,000     0     0   9,600     0     0  			*(*(pH+nrx)+layer)=*(*(pHTranspose+layer)+nrx);
  139,200    1    1  52,800     0     0  24,000     0     0  			*(*(pHDagger+layer)+nrx)=conj((*(*(pHTranspose+layer)+nrx)));
        .    .    .       .     .     .       .     .     .  		}
        .    .    .       .     .     .       .     .     .  	}
   12,000    1    1   7,200     0     0   1,200     0     0  	MatrixProd<int,std::complex<float> >(NumLayer,NumRxAntenna,NumLayer,pHDagger,pH,pHDH);
    7,200    0    0   3,600     0     0   1,200     0     0  	MatrixInv<int,std::complex<float> >(NumLayer,pHDH,pInvHDH);
        .    .    .       .     .     .       .     .     .  
        .    .    .       .     .     .       .     .     .  	////////////////// Equalizing Data /////////////////
  110,400    3    3  45,600     0     0   1,200     0     0  	for(int nSymb=0;nSymb<NumULSymbSF-2;nSymb++)
        .    .    .       .     .     .       .     .     .  	{
  518,400    1    1  14,400     0     0  57,600     0     0  		std::complex<float>* pYData=new std::complex<float>[NumRxAntenna];
  273,600    1    1 115,200     0     0  14,400     0     0  		for(int nrx=0;nrx<NumRxAntenna;nrx++)
        .    .    .       .     .     .       .     .     .  		{
  288,000    1    1 115,200     0     0  28,800     0     0  			int IDX=(NumULSymbSF-2)*nrx+nSymb+2*NumRxAntenna;
        .    .    .       .     .     .       .     .     .  			//	*(pYData+nrx)=*(*(pInpData+IDX)+m);
  518,400    0    0 230,400 3,624 3,601  57,600     0     0  			*(pYData + nrx) = pInpData[IDX * MDFTPerUser + m];
        .    .    .       .     .     .       .     .     .  		}
  158,400    1    1  72,000     0     0  14,400     0     0  		MatrixProd<int,std::complex<float> >(NumLayer,NumRxAntenna,1,pHDagger,pYData,pHDY);
        .    .    .       .     .     .       .     .     .  
  518,400    1    1  14,400     0     0  57,600     0     0  		std::complex<float>* pXData=new std::complex<float>[NumLayer];
  158,400    1    1  72,000     0     0  14,400     0     0  		MatrixProd<int,std::complex<float> >(NumLayer,NumLayer,1,pInvHDH,pHDY,pXData);
        .    .    .       .     .     .       .     .     .  
        .    .    .       .     .     .       .     .     .  		/////////////////////// Get EqW ////////////////////////
   86,400    0    0  14,400     0     0  28,800     0     0  		std::complex<float> **pW = new std::complex<float>*[NumLayer];
1,454,400    3    3 201,600     0     0 129,600     0     0  		for(int layer=0;layer<NumLayer;layer++){*(pW+layer)=new std::complex<float>[NumRxAntenna];}
  158,400    0    0  72,000     0     0  14,400     0     0  		MatrixProd<int,std::complex<float> >(NumLayer,NumLayer,1,pInvHDH,pHDagger,pW);
  273,600    1    1 115,200     0     0  14,400     0     0  		for(int layer=0;layer<NumLayer;layer++)
        .    .    .       .     .     .       .     .     .  		{
  547,200    2    2 230,400     0     0  28,800     0     0  			for(int nrx=0;nrx<NumRxAntenna;nrx++)
1,670,400    0    0 691,200   753     0 115,200 1,200     0  			{*(*(*(pEqW+m)+layer)+nrx)=*(*(pW+layer)+nrx);}
        .    .    .       .     .     .       .     .     .  		}   
  734,400    1    1 288,000     0     0  43,200     0     0  		for(int layer=0;layer<NumLayer;layer++){delete[] *(pW+layer);}
   72,000    1    1  28,800     0     0  14,400     0     0  		delete[] pW;
        .    .    .       .     .     .       .     .     .  		////////////////////////END Get EqW/////////////////////
        .    .    .       .     .     .       .     .     .  		//////////////////////// Get pHdm ////////////////////////
  273,600    1    1 115,200     0     0  14,400     0     0  		for(int nrx=0;nrx<NumRxAntenna;nrx++)
        .    .    .       .     .     .       .     .     .  		{
  547,200    0    0 230,400     0     0  28,800     0     0  			for(int layer=0;layer<NumLayer;layer++)
1,670,400    1    1 691,200   752     0 115,200 1,199     0  			{*(*(*(pHdm+m)+nrx)+layer)=*(*(pH+nrx)+layer);}
        .    .    .       .     .     .       .     .     .  		}
        .    .    .       .     .     .       .     .     .  		/////////////////////// END Get pHdm /////////////////////
  273,600    2    2 115,200     0     0  14,400     0     0  		for(int layer=0;layer<NumLayer;layer++)
        .    .    .       .     .     .       .     .     .  		{
  201,600    0    0  86,400     0     0  28,800     0     0  			int IDX = (NumULSymbSF-2)*layer+nSymb;
        .    .    .       .     .     .       .     .     .  			
        .    .    .       .     .     .       .     .     .  			//	*(*(pOutData+IDX)+m)=*(pXData+layer);
  518,400    0    0 230,400     0     0  57,600 3,624 3,601  			pOutData[IDX * MDFTPerUser + m] = *(pXData+layer);
        .    .    .       .     .     .       .     .     .  		}
        .    .    .       .     .     .       .     .     .  
   72,000    0    0  28,800     0     0  14,400     0     0  		delete[] pYData;
   72,000    0    0  28,800     0     0  14,400     0     0  		delete[] pXData;
        .    .    .       .     .     .       .     .     .  	}
        .    .    .       .     .     .       .     .     .  	//////////////// END Equalizing Data ///////////////  
        .    .    .       .     .     .       .     .     .  
   61,200    1    1  24,000     0     0   3,600     0     0  	for(int nrx=0;nrx<NumRxAntenna;nrx++){delete[] *(pH+nrx);}
    6,000    0    0   2,400     0     0   1,200     0     0  	delete[] pH;
   22,800    2    2   9,600     0     0   1,200     0     0  	for(int layer=0;layer<NumLayer;layer++)
  115,200    2    2  43,200     0     0   7,200     0     0  	{delete[] *(pHDagger+layer);delete[] *(pHDH+layer);delete[] *(pInvHDH+layer);}
    6,000    0    0   2,400     0     0   1,200     0     0  	delete[] pHDagger;
    6,000    0    0   2,400     0     0   1,200     0     0  	delete[] pHDH;
    6,000    1    1   2,400     0     0   1,200     0     0  	delete[] pInvHDH;
        .    .    .       .     .     .       .     .     .  
    6,000    0    0   2,400     0     0   1,200     0     0  	delete[] pHDY;
        .    .    .       .     .     .       .     .     .  //////////////////// END Freq Domain Equalize received Data//////////////////
        .    .    .       .     .     .       .     .     .  
    7,200    0    0   6,000     0     0       0     0     0  }
        .    .    .       .     .     .       .     .     .  
        .    .    .       .     .     .       .     .     .  
        .    .    .       .     .     .       .     .     .  /////////////////////////Frequency Domain MMSE Equalization///////////////////////////////////
        .    .    .       .     .     .       .     .     .  ////////////////////////////////////////////////////////////
        .    .    .       .     .     .       .     .     .  void FDMMSEEqualization(std::complex<float> *pInpData, std::complex<float>** pHTranspose, int m, int NumLayer, int NumRxAntenna, int MDFTPerUser, float No, std::complex<float> *pOutData)
        .    .    .       .     .     .       .     .     .  {
        .    .    .       .     .     .       .     .     .  	int NumULSymbSF = LTE_PHY_N_SYMB_PER_SUBFR;
        .    .    .       .     .     .       .     .     .  //////////////////// Freq Domain Equalize received Data /////////////////
-- line 151 ----------------------------------------
-- line 227 ----------------------------------------
        .    .    .       .     .     .       .     .     .  //////////////////// END Freq Domain Equalize received Data//////////////////
        .    .    .       .     .     .       .     .     .  
        .    .    .       .     .     .       .     .     .  }
        .    .    .       .     .     .       .     .     .  
        .    .    .       .     .     .       .     .     .  ////////////////////////////////////////////////////////////
        .    .    .       .     .     .       .     .     .  /////////////////////////END Frequency Domain MMSE Equalization///////////////////////////////////
        .    .    .       .     .     .       .     .     .  
        .    .    .       .     .     .       .     .     .  void LSFreqDomain(std::complex<float> *pInpData, std::complex<float> *pOutData, int MDFT, int NumLayer, int NumRxAntenna)
       12    2    2       0     0     0      10     3     3  {
   96,008    1    1       0     0     0   9,600     0     0  	std::complex<float> pDMRS[2 * LTE_PHY_N_ANT_MAX * LTE_PHY_DFT_SIZE_MAX];
        .    .    .       .     .     .       .     .     .  //	pDMRS = (*VpUser).GetpDMRS();
        6    0    0       2     1     0       1     0     0  	geneDMRS(pDMRS, NumLayer, MDFT);
        .    .    .       .     .     .       .     .     .    
    7,207    1    1   3,602     1     0       1     1     0  	for(int m=0;m<MDFT;m++)
        .    .    .       .     .     .       .     .     .  	{
    3,600    1    1       0     0     0   2,400     1     0  		std::complex<float>** pXt=new std::complex<float>*[2];
  117,600    2    2  13,200     0     0  10,800     0     0  		for(int slot=0;slot<2;slot++){*(pXt+slot)=new std::complex<float>[NumLayer];}
    7,200    0    0   1,200     0     0   2,400     0     0  		std::complex<float>** pXtDagger = new std::complex<float>* [NumLayer];
  111,600    2    2  14,400     0     0  10,800     0     0  		for(int layer=0;layer<NumLayer;layer++){*(pXtDagger+layer)=new std::complex<float>[2];}
   19,200    1    1   6,000     0     0   1,200     0     0  		for(int slot=0;slot<2;slot++)
        .    .    .       .     .     .       .     .     .  		{
   45,600    0    0  19,200     0     0   2,400     0     0  			for(int layer=0;layer<NumLayer;layer++)
        .    .    .       .     .     .       .     .     .  			{
        .    .    .       .     .     .       .     .     .  				//	*(*(pXt+slot)+layer)=*(*(*(pDMRS+slot)+layer)+m);
  115,200    1    1  52,800   601     0   9,600     0     0  				*(*(pXt+slot)+layer)= pDMRS[(slot * NumLayer + layer) * MDFT + m];
        .    .    .       .     .     .       .     .     .  				//	*(*(pXtDagger+layer)+slot)=conj((*(*(*(pDMRS+slot)+layer)+m)));
  153,600    2    2  57,600     0     0  24,000     0     0  				*(*(pXtDagger+layer)+slot)=conj(pDMRS[(slot * NumLayer + layer) * MDFT + m]);
        .    .    .       .     .     .       .     .     .  			}
        .    .    .       .     .     .       .     .     .  		}
        .    .    .       .     .     .       .     .     .  
    3,600    0    0       0     0     0   2,400     0     0  		std::complex<float>** pYt=new std::complex<float>*[2];
  117,600    2    2  13,200     0     0  10,800     0     0  		for(int slot=0;slot<2;slot++){*(pYt+slot)=new std::complex<float>[NumRxAntenna];}
   19,200    2    2   6,000     0     0   1,200     0     0  		for(int slot=0;slot<2;slot++)
        .    .    .       .     .     .       .     .     .  		{
   45,600    1    1  19,200     0     0   2,400     0     0  			for(int nrx=0;nrx<NumRxAntenna;nrx++)
        .    .    .       .     .     .       .     .     .  			{
  124,800    0    0  52,800   604   599   9,600     0     0  				*(*(pYt+slot)+nrx) = pInpData[(nrx * 2 + slot) * MDFT + m];
        .    .    .       .     .     .       .     .     .  			}
        .    .    .       .     .     .       .     .     .  		}
        .    .    .       .     .     .       .     .     .  
    7,200    0    0   1,200     0     0   2,400     0     0  		std::complex<float>** pHTranspose=new std::complex<float>*[NumLayer];
  121,200    2    2  16,800     0     0  10,800     0     0  		for(int layer=0;layer<NumLayer;layer++){*(pHTranspose+layer)=new std::complex<float>[NumRxAntenna];}
        .    .    .       .     .     .       .     .     .  
   12,000    1    1   7,200     0     0   1,200     0     0  		FDLSEstimation(pXt, pXtDagger, pYt, pHTranspose, NumLayer, NumRxAntenna);
        .    .    .       .     .     .       .     .     .  
   12,000    0    0   8,400     0     0   2,400     0     0  		FDLSEqualization(pInpData, pHTranspose, m, NumLayer, NumRxAntenna, MDFT, pOutData); 
        .    .    .       .     .     .       .     .     .  
   57,600    2    2  20,400     0     0   3,600     0     0  		for(int slot=0;slot<2;slot++){delete[] *(pXt+slot);}
    6,000    0    0   2,400     0     0   1,200     0     0  		delete[] pXt;
   61,200    1    1  24,000     0     0   3,600     0     0  		for(int layer=0;layer<NumLayer;layer++){delete[] *(pXtDagger+layer);}
    6,000    1    1   2,400     0     0   1,200     0     0  		delete[] pXtDagger;
        .    .    .       .     .     .       .     .     .  
   57,600    1    1  20,400     0     0   3,600     0     0  		for(int slot=0;slot<2;slot++){delete[] *(pYt+slot);}
    6,000    0    0   2,400     0     0   1,200     0     0  		delete[] pYt; 
        .    .    .       .     .     .       .     .     .  
   61,200    1    1  24,000     0     0   3,600     0     0  		for(int layer=0;layer<NumLayer;layer++){delete[]  *(pHTranspose+layer);}
    6,000    0    0   2,400     0     0   1,200     0     0  		delete[] pHTranspose;
        .    .    .       .     .     .       .     .     .  	}
        7    1    0       5     1     0       0     0     0  }
        .    .    .       .     .     .       .     .     .  
        .    .    .       .     .     .       .     .     .  void Equalizing(LTE_PHY_PARAMS *lte_phy_params, std::complex<float> *pInpData, std::complex<float> *pOutData)
        7    1    1       0     0     0       5     0     0  {
        3    0    0       2     1     0       1     0     0  	int MDFT = lte_phy_params->N_dft_sz;
        3    0    0       2     1     0       1     0     0  	int NumLayer = lte_phy_params->N_tx_ant;
        3    1    1       2     0     0       1     0     0  	int NumRxAntenna = lte_phy_params->N_rx_ant;
        .    .    .       .     .     .       .     .     .  	
        8    0    0       5     0     0       1     0     0  	LSFreqDomain(pInpData, pOutData, MDFT, NumLayer, NumRxAntenna);
        2    1    0       2     1     0       0     0     0  }
        .    .    .       .     .     .       .     .     .  
        .    .    .       .     .     .       .     .     .  /*
        .    .    .       .     .     .       .     .     .    void Equalizer::Equalizing(FIFO<complex<float> >* pOutBuf,complex<float>***pPCSI,float AWGNNo)
        .    .    .       .     .     .       .     .     .    {
        .    .    .       .     .     .       .     .     .    if(PSFlag)
        .    .    .       .     .     .       .     .     .    {cout<<"Equalizing"<<endl;}
        .    .    .       .     .     .       .     .     .  //VpInpBuf=pInpBuf;
        .    .    .       .     .     .       .     .     .  VpOutBuf=pOutBuf;
-- line 302 ----------------------------------------
-- line 344 ----------------------------------------
        .    .    .       .     .     .       .     .     .  }
        .    .    .       .     .     .       .     .     .  else
        .    .    .       .     .     .       .     .     .  {cout<<"fail to read data from previous buffer"<<endl;}
        .    .    .       .     .     .       .     .     .  
        .    .    .       .     .     .       .     .     .  }
        .    .    .       .     .     .       .     .     .  */
        .    .    .       .     .     .       .     .     .  
        .    .    .       .     .     .       .     .     .  void Equalizer_cleanup(LTE_PHY_PARAMS *lte_phy_params)
        5    0    0       0     0     0       3     0     0  {
        3    1    1       2     1     0       1     0     0  	int MDFTPerUser = lte_phy_params->N_dft_sz;
        3    0    0       2     1     0       1     0     0  	int NumLayerPerUser = lte_phy_params->N_tx_ant;
        3    0    0       2     0     0       1     0     0  	int NumRxAntenna = lte_phy_params->N_rx_ant;
        .    .    .       .     .     .       .     .     .  
    7,207    1    1   3,602     0     0       1     0     0  	for(int m=0;m<MDFTPerUser;m++)
        .    .    .       .     .     .       .     .     .  	{
   22,800    1    1   9,600     0     0   1,200     0     0  		for(int l=0;l<NumLayerPerUser;l++)
        .    .    .       .     .     .       .     .     .  		{
   62,400    1    1  24,000   753     0   2,400     0     0  			delete[] *(*(pEqW+m)+l);
        .    .    .       .     .     .       .     .     .  		}
        .    .    .       .     .     .       .     .     .  
   22,800    1    1   9,600     0     0   1,200     0     0  		for(int nrx=0;nrx<NumRxAntenna;nrx++)
        .    .    .       .     .     .       .     .     .  		{
   62,400    0    0  24,000   152     0   2,400     0     0  			delete[] *(*(pHdm+m)+nrx);
        .    .    .       .     .     .       .     .     .  		}
        .    .    .       .     .     .       .     .     .  	}
        .    .    .       .     .     .       .     .     .  
    7,207    1    1   3,602     0     0       1     0     0  	for(int m=0;m<MDFTPerUser;m++)
        .    .    .       .     .     .       .     .     .  	{
   19,200    1    1   7,200   151     0   1,200     0     0  		delete[] *(pEqW+m);
   19,200    0    0   7,200   150     0   1,200     0     0  		delete[] *(pHdm+m);
        .    .    .       .     .     .       .     .     .  	}
        .    .    .       .     .     .       .     .     .  
        6    1    0       2     0     0       1     0     0  	delete[] pEqW;
        6    0    0       2     0     0       1     0     0  	delete[] pHdm;
       22    3    3       8     0     0       7     0     0  }

--------------------------------------------------------------------------------
Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 
--------------------------------------------------------------------------------
 3    4    4  3   25   37  2    3    2  percentage of events annotated

